syntax = "proto3";
package lumera.audit.v1;

option go_package = "x/audit/v1/types";

import "amino/amino.proto";
import "cosmos_proto/cosmos.proto";
import "gogoproto/gogo.proto";

enum PortState {
  PORT_STATE_UNKNOWN = 0;
  PORT_STATE_OPEN    = 1;
  PORT_STATE_CLOSED  = 2;
}

message AuditSelfReport {
  double cpu_usage_percent  = 1;
  double mem_usage_percent  = 2;
  double disk_usage_percent = 3;

  repeated PortState inbound_port_states = 4;

  uint32 failed_actions_count = 5;
}

message AuditPeerObservation {
  string target_supernode_account = 1 [(cosmos_proto.scalar) = "cosmos.AccAddressString"];

  // port_states[i] refers to required_open_ports[i] for the window.
  repeated PortState port_states = 2;
}

message AuditReport {
  string supernode_account = 1 [(cosmos_proto.scalar) = "cosmos.AccAddressString"];
  uint64 window_id         = 2;
  int64 report_height      = 3;

  AuditSelfReport self_report = 4 [(gogoproto.nullable) = false];
  repeated AuditPeerObservation peer_observations = 5;
}

// ProberTargets captures the deterministic prober -> targets mapping for a window.
message ProberTargets {
  string prober_supernode_account = 1 [(cosmos_proto.scalar) = "cosmos.AccAddressString"];
  repeated string target_supernode_accounts = 2 [(cosmos_proto.scalar) = "cosmos.AccAddressString"];
}

message WindowSnapshot {
  uint64 window_id          = 1;
  int64  window_start_height = 2;

  // assignments is the minimal per-window source-of-truth for prober -> targets mapping.
  repeated ProberTargets assignments = 3 [(gogoproto.nullable) = false];
}
